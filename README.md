Завдання 1.

Розробити алгоритм і програму для побудови дерев рішень. Виконати опрацювання набору тестових даних з метою синтезу дерева рішень. Проаналізувати побудоване дерево рішень.

Побудова дерева рішень на Python
1. Опис завдання та методологія

Мета роботи:
Розробити програму на Python для побудови (синтезу) дерева рішень, виконати опрацювання тестового набору даних та провести детальний аналіз отриманої моделі класифікації.

Використані інструменти

Мова програмування: Python 3

Основна бібліотека: scikit-learn – для побудови дерева рішень, розділення даних та оцінки моделі

Допоміжні бібліотеки:

matplotlib – для візуалізації дерева

pandas, numpy – для роботи з даними

Хід виконання роботи

1. Завантаження даних:
Використано класичний набір даних Iris (load_iris з scikit-learn), який містить 150 зразків трьох класів – setosa, versicolor, virginica – та 4 ознаки (довжина і ширина пелюсток та чашолистків).

2. Розділення вибірки:

Тренувальний набір: 105 зразків (70%)

Тестовий набір: 45 зразків (30%)

3. Синтез дерева рішень:
Використано модель:

DecisionTreeClassifier(criterion='entropy', max_depth=3, random_state=42)

    Критерій розділення – ентропія (Information Gain)

    Навчання моделі виконано методом .fit(X_train, y_train)

4. Аналіз моделі:

    Отримано текстові правила за допомогою export_text()

    Побудовано візуальне представлення дерева за допомогою plot_tree()

    Проведено оцінку ефективності:

        Точність (Accuracy)

        Матриця помилок (Confusion Matrix)

        Метрики Precision, Recall, F1-score

2. Код програми
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree, export_text
from sklearn import metrics


iris = load_iris()
X = iris.data
y = iris.target
feature_names = iris.feature_names
target_names = iris.target_names


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

print(f"Розмір тренувального набору: {X_train.shape[0]} зразків")
print(f"Розмір тестового набору: {X_test.shape[0]} зразків")
print("-" * 30)


clf = DecisionTreeClassifier(criterion='entropy', max_depth=3, random_state=42)


clf.fit(X_train, y_train)

print("Дерево рішень успішно побудовано.")
print("-" * 30)


print("Текстове представлення дерева рішень:")
text_representation = export_text(clf, feature_names=feature_names)
print(text_representation)
print("-" * 30)


print("Візуалізація дерева рішень (дивіться у окремому вікні)...")
plt.figure(figsize=(15, 10))
plot_tree(clf, 
          feature_names=feature_names, 
          class_names=target_names, 
          filled=True, 
          rounded=True) 

plt.show()


y_pred = clf.predict(X_test)


accuracy = metrics.accuracy_score(y_test, y_pred)
print(f"Точність (Accuracy) на тестових даних: {accuracy:.2f}")


print("\nМатриця помилок:")
print(metrics.confusion_matrix(y_test, y_pred))


print("\nДетальний звіт по класифікації:")
print(metrics.classification_report(y_test, y_pred, target_names=target_names))



3. Результати виконання роботи
<img width="1206" height="821" alt="изображение" src="https://github.com/user-attachments/assets/b1661950-d6ef-40f3-8fd5-faf4c30afb8f" />

Рисунок 1. Графічна візуалізація дерева рішень
На рисунку показано структуру дерева, побудованого на 105 зразках тренувальної вибірки. Кожен вузол містить:

Rule – правило розділення, обране за критерієм приросту інформації

entropy – показник "нечистоти" вузла (0.0 – чистий вузол)

samples – кількість зразків у вузлі

value – розподіл зразків по класах

class – домінуючий клас у вузлі







<img width="424" height="692" alt="изображение" src="https://github.com/user-attachments/assets/3b9b3fa1-fca9-4feb-b512-ceb4cd436e00" />


Рисунок 2. Текстове представлення дерева рішень та оцінка ефективності

Текстове представлення: правила "ЯКЩО-ТОДІ", що відображають логіку моделі

Метрики ефективності:

Accuracy: ~0.96 (96%)

Confusion Matrix: показує лише одну неправильну класифікацію з 45 тестових зразків

Classification Report: високі показники precision, recall та F1-score для всіх класів

Висновок до завдання
Під час виконання роботи було успішно розроблено програму на Python для синтезу та аналізу дерева рішень. На основі тренувального набору даних "Іриси" (105 зразків) було побудовано модель класифікації з обмеженою глибиною (max_depth=3).
Аналіз показав, що ключовими ознаками для класифікації є petal length (cm) та petal width (cm).
Тестування моделі на незалежному наборі даних (45 зразків) продемонструвало її високу ефективність, досягнувши точності (Accuracy) 98%. Матриця помилок підтвердила, що модель допустила лише одну помилку, коректно обробивши 44 з 45 зразків. Це свідчить про те, що побудоване дерево є надійною та добре узагальнюючою моделлю.






















Завдання 2

Виконати обчислення коефіцієнта кореляції між змінними ліпопротеїнів та
гемоглобіну. Здійснити аналіз отриманих результатів і прописати грунтовний
висновок про тип отриманого взаємозв’язку з урахуванням коефіцієнтів
кореляції (на прикладі виконаних завдань лабораторного практикуму).

1. Мета роботи

Метою даної роботи є обчислення коефіцієнта кореляції між двома змінними — рівнем гемоглобіну та рівнем ліпопротеїнів. На основі отриманого коефіцієнта проведено ґрунтовний аналіз типу та сили взаємозв’язку між показниками.

2. Використані інструменти та методологія

Мова програмування: Python

Бібліотеки:

pandas – для створення таблиці даних (DataFrame) та обчислень

numpy – для роботи з масивами даних

Метод аналізу:
Для визначення лінійного взаємозв’язку використано коефіцієнт кореляції Пірсона (r). Цей метод дозволяє оцінити:

Напрямок зв’язку: від -1 до +1

Силу зв’язку: чим ближче абсолютне значення до 1, тим сильніший лінійний взаємозв’язок

3. Код програми
import pandas as pd
import numpy as np

data = {
    'hemoglobin': [131, 135, 140, 142, 148, 150, 155, 160, 162, 170],
    'lipoproteins': [4.1, 4.3, 4.0, 4.6, 4.9, 5.0, 5.3, 5.8, 5.7, 6.2]
}

df = pd.DataFrame(data)

print("Наші вихідні дані:")
print(df)
print("-" * 30)


correlation_coefficient = df['hemoglobin'].corr(df['lipoproteins'])

print(f"Коефіцієнт кореляції Пірсона (r) між \n"
      f"гемоглобіном та ліпопротеїнами: {correlation_coefficient:.4f}")


print("\nМатриця кореляцій:")
print(df.corr())



4. Результати обчислень
<img width="413" height="821" alt="изображение" src="https://github.com/user-attachments/assets/764ffc1a-4ed0-45b3-b044-eba5f2584d46" />

Рисунок 1. Результати виконання програми:

Вивід вихідних даних

Коефіцієнт кореляції Пірсона

Отриманий коефіцієнт: r = 0.9712

Матриця кореляцій:
hemoglobin  lipoproteins
hemoglobin       1.0000        0.9712
lipoproteins     0.9712        1.0000

5. Аналіз отриманих результатів та висновок

Напрямок зв’язку:
Коефіцієнт кореляції є додатним (+0.9712), що свідчить про прямий зв’язок між рівнем гемоглобіну та ліпопротеїнів. Зі збільшенням гемоглобіну спостерігається збільшення ліпопротеїнів.

Сила зв’язку:
Абсолютне значення коефіцієнта кореляції потрапляє у діапазон 0.9–1.0, що за шкалою Чеддока відповідає дуже сильному лінійному зв’язку. Зв’язок між змінними є вираженим та стабільним.

Висновок:
Отримані дані свідчать про наявність статистично значущої, дуже сильної та прямої залежності між рівнем гемоглобіну та ліпопротеїнів у досліджуваній вибірці.
Важливо: кореляція не доводить причинно-наслідковий зв’язок — високий рівень гемоглобіну не обов’язково спричиняє підвищення ліпопротеїнів. Ймовірно, на обидва показники впливає третій фактор (наприклад, метаболізм, дієта, вік, супутні захворювання).

6. Висновок до завдання

Проведено статистичний аналіз взаємозв’язку між рівнем гемоглобіну та ліпопротеїнів.

Коефіцієнт кореляції Пірсона склав r = 0.9712.

Виявлено дуже сильний прямий лінійний зв’язок між показниками.

Підкреслено, що кореляція не є доказом причинно-наслідкового зв’язку.
































Завдання 3

Здійснити обчислення параметрів нелінійної моделі для аналізу форми зв’язку
між незалежною змінною «стабілізована глюкоза» та залежною змінною
«гемоглобін». Визначити методи оцінювання параметрів нелінійних моделей
(на прикладі завдань лабораторного практикуму). Оцінити якість отриманої
нелінійної моделі.

1. Мета роботи

Метою роботи є обчислення параметрів нелінійної моделі для аналізу взаємозв’язку між незалежною змінною «стабілізована глюкоза» та залежною змінною «гемоглобін». Необхідно визначити методи оцінювання параметрів та оцінити якість отриманої моделі.

2. Методологія та використані методи
2.1. Визначення методу оцінювання параметрів

Для аналізу форми зв’язку обрана поліноміальна регресія 2-го ступеня (параболічна модель). Вона дозволяє описати наявність максимального або мінімального піку у даних.

Рівняння моделі:

<img width="256" height="50" alt="изображение" src="https://github.com/user-attachments/assets/bae3d0ec-d31e-4c4e-9a18-4792246aa71f" />

Хоча модель є нелінійною щодо змінної X, вона лінійна щодо параметрів a, b1, b2.

Використано Метод Найменших Квадратів (МНК) для обчислення параметрів, мінімізуючи суму квадратів відхилень між фактичними та прогнозними значеннями Y.

Трансформація ознак:
<img width="232" height="49" alt="изображение" src="https://github.com/user-attachments/assets/e52f4a23-3c2e-42e1-a4bb-2f4f13bc33a3" />


2.2. Використані інструменти

Мова програмування: Python

Бібліотеки:

numpy та pandas – робота з даними

scikit-learn – PolynomialFeatures, LinearRegression

Оцінка якості: Коефіцієнт детермінації (R²)

3. Код програми
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import r2_score


X_glucose = np.array([4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5])
y_hemoglobin = np.array([130, 140, 147, 150, 151, 149, 145, 138, 130, 120])


X = X_glucose.reshape(-1, 1)
y = y_hemoglobin

print("Вихідні дані:")
df = pd.DataFrame({'Глюкоза (X)': X_glucose, 'Гемоглобін (Y)': y_hemoglobin})
print(df)
print("-" * 30)


poly = PolynomialFeatures(degree=2, include_bias=False)
X_poly = poly.fit_transform(X)


print("Трансформовані ознаки (Z1 = X та Z2 = X^2):")
print(pd.DataFrame(X_poly, columns=['X', 'X^2']).head())
print("-" * 30)


model = LinearRegression()
model.fit(X_poly, y)


a = model.intercept_  
b1 = model.coef_[0]   
b2 = model.coef_[1]   

print("--- 1. Обчислені Параметри Моделі ---")
print(f"Вільний член (a):     {a:.4f}")
print(f"Коефіцієнт b1 (при X): {b1:.4f}")
print(f"Коефіцієнт b2 (при X^2): {b2:.4f}")
print("-" * 30)


y_pred = model.predict(X_poly)


r2 = r2_score(y, y_pred)


print("--- 2. Оцінка Якості Моделі ---")
print(f"Коефіцієнт детермінації (R^2): {r2:.4f}")



4. Результати виконання роботи
<img width="368" height="481" alt="изображение" src="https://github.com/user-attachments/assets/f4f76ce0-1ce8-40c4-b809-64cb426401ac" />
Рисунок 1. Консольний вивід програми:

Вихідні дані

Трансформовані ознаки Z1, Z2

Обчислені параметри a, b1, b2

Оцінка якості моделі (R²)

Обчислені параметри:

Параметр	Значення
a	-28.1818
b1	59.8091
b2	-5.0000


<img width="675" height="51" alt="изображение" src="https://github.com/user-attachments/assets/708ca874-2ad5-4311-927f-e64f904fb646" />

Якість моделі:

R2=0.9942 

5. Аналіз результатів та висновок
5.1. Аналіз параметрів та форми зв’язку

Коефіцієнт b2 = -5.0 від’ємний → парабола відкривається вниз (∩)

Зі збільшенням глюкози: гемоглобін спочатку зростає, досягає піку, потім знижується.

Модель адекватно описує нелінійний зв’язок між змінними.

5.2. Оцінка якості моделі

R² = 0.9942 → модель пояснює 99.42% мінливості рівня гемоглобіну.

Параболічна форма описує дані практично ідеально.

6. Висновок до завдання

Параметри a, b1, b2 обчислено за допомогою Методу Найменших Квадратів для лінеаризованої поліноміальної моделі 2-го ступеня.

Отримане рівняння описує параболічний зв’язок: гемоглобін зростає до піку при певному рівні глюкози, потім знижується.

Якість моделі є відмінною (R² = 0.9942), що підтверджує адекватність обраної форми моделі для даних лабораторного практикуму.























Завдання 4
Визначити та побудувати функцію регресії у вигляді математичного рівняння
(на прикладі розробленої моделі лабораторного практикуму) та встановити
вплив змінних на залежну величину. Оцінити побудовану регресійну модель.

1. Мета роботи

Метою роботи є побудова функції регресії у вигляді математичного рівняння на прикладі розробленої моделі лабораторного практикуму. Необхідно визначити вплив незалежної змінної на залежну величину та оцінити якість побудованої регресійної моделі.

2. Код програми
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import r2_score

X_glucose = np.array([4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5])
y_hemoglobin = np.array([130, 140, 147, 150, 151, 149, 145, 138, 130, 120])


X = X_glucose.reshape(-1, 1)
y = y_hemoglobin


poly = PolynomialFeatures(degree=2, include_bias=False)
X_poly = poly.fit_transform(X)


model = LinearRegression()
model.fit(X_poly, y)


a = model.intercept_  
b1 = model.coef_[0]   
b2 = model.coef_[1]   


y_pred = model.predict(X_poly)
r2 = r2_score(y, y_pred)



print("="*50)
print("     АНАЛІЗ ОТРИМАНОЇ РЕГРЕСІЙНОЇ МОДЕЛІ")
print("="*50)


print("\n1. Функція Регресії (Рівняння)")
print(f"Модель: Y = a + b1*X + b2*X^2")
print(f"Обчислені параметри:")
print(f"  a (Вільний член) = {a:.4f}")
print(f"  b1 (при X)       = {b1:.4f}")
print(f"  b2 (при X^2)     = {b2:.4f}")
print("\nФІНАЛЬНЕ МАТЕМАТИЧНЕ РІВНЯННЯ:")
print(f"  Гемоглобін = {a:.4f} + {b1:.4f} * (Глюкоза) {b2:.4f} * (Глюкоза)^2")
print("-" * 50)



print("\n2. Вплив Змінних (Аналіз)")
print(f"Коефіцієнт b2 (при X^2) дорівнює {b2:.4f}.")
if b2 < 0:
    print("Оскільки b2 ВІД'ЄМНИЙ, форма зв'язку - це ПАРАБОЛА,")
    print("гілки якої спрямовані ВНИЗ (∩). ")
    print("Це означає, що вплив глюкози на гемоглобін нелінійний:")
    print("  1. Спочатку (при низькій глюкозі) її зростання ПОЗИТИВНО впливає на гемоглобін (він росте).")
    print("  2. Після досягнення точки піку, подальше зростання глюкози НЕГАТИВНО впливає на гемоглобін (він знижується).")
elif b2 > 0:
    print("Оскільки b2 ДОДАТНІЙ, форма зв'язку - це ПАРАБОЛА,")
    print("гілки якої спрямовані ВГОРУ (∪).")
    print("Вплив глюкози: гемоглобін спочатку знижується, досягає мінімуму, а потім починає зростати.")
else:
    print("Оскільки b2 = 0, зв'язок є лінійним, а не параболічним.")
print("-" * 50)



print("\n 3. Оцінка Якості Моделі")
print(f"Коефіцієнт детермінації (R^2) = {r2:.4f}")
print(f"Це означає, що побудована модель пояснює {r2*100:.2f}%")
print("всієї мінливості (варіації) рівня гемоглобіну.")
if r2 > 0.95:
    print("Оцінка якості: ВІДМІННА. Модель дуже добре описує дані.")
elif r2 > 0.8:
    print("Оцінка якості: ДУЖЕ ДОБРА. Модель добре описує дані.")
elif r2 > 0.6:
    print("Оцінка якості: ЗАДОВІЛЬНА. Модель пояснює більшу частину даних.")
else:
    print("Оцінка якості: СЛАБКА. Модель погано описує дані.")
print("="*50)


3. Результати виконання
<img width="787" height="517" alt="изображение" src="https://github.com/user-attachments/assets/eeb39cd1-9d26-411c-b340-5632e3a8ba4f" />
Скріншот виводу у коснолі після запуску коду

Після запуску скрипту отримано повний аналітичний звіт, що включає:

Функцію регресії у вигляді математичного рівняння

Вплив незалежної змінної на залежну

Оцінку якості моделі

Функція регресії:
<img width="660" height="42" alt="изображение" src="https://github.com/user-attachments/assets/8d3ba6e4-2f37-43e4-8723-d1ebba156b99" />


4. Аналіз результатів
4.1. Вплив змінних

Коефіцієнт b2 = -5.0 → форма зв'язку параболічна, гілки вниз (∩)

При низьких рівнях глюкози гемоглобін зростає

Після досягнення піку подальше зростання глюкози призводить до зниження гемоглобіну

4.2. Оцінка моделі

Коефіцієнт детермінації R² = 0.9942

Модель пояснює 99.42% мінливості рівня гемоглобіну

Оцінка якості: Відмінна

5. Висновок до завдання

Успішно побудовано математичне рівняння регресії:
<img width="583" height="36" alt="изображение" src="https://github.com/user-attachments/assets/21fa427f-2b24-40dd-a139-639189bfa503" />

Встановлено параболічний вплив глюкози на гемоглобін: зростання до піку, потім зниження

Якість моделі оцінена як відмінна (R² = 0.9942), що підтверджує високу надійність регресійної функції












































































































































































































































































































































